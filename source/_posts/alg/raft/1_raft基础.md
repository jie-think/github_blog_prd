# raft 基础理论

参考: https://www.jianshu.com/p/096ae57d1fe0



问题分解为：领导选取、日志复制、安全和成员变化



## 基础概念

### 复制状态机

![复制状态机](https://upload-images.jianshu.io/upload_images/3412164-922866cdd2dd47c6.png)

- 复制状态机通过复制日志来实现：
  - 日志：每台机器保存一份日志，日志来自于客户端的请求，包含一系列的命令
  - 状态机：状态机会按顺序执行这些命令
  - 一致性模型：分布式环境下，保证多机的日志是一致的，这样回放到状态机中的状态是一致的



### 服务器状态

每台服务器均有可能存在下面三种情况:

1. 领导者
2. 候选人
3. 追随者

![服务器转态转换图](https://upload-images.jianshu.io/upload_images/3412164-07ae960bce59aab5.png)

追随者只响应其他服务器的请求。如果追随者没有收到任何消息，它会成为一个候选人并且开始一次选举。收到大多数服务器投票的候选人会成为新的领导人。领导人在它们宕机之前会一直保持领导人的状态。



### 任期

Raft 算法将时间划分成为任意不同长度的任期（term）。任期用连续的数字进行表示。每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。Raft 算法保证在给定的一个任期最多只有一个领导人。

![任期示意图](https://upload-images.jianshu.io/upload_images/3412164-d67cbaab1479a864.png)

### RPC

Raft 算法中服务器节点之间通信使用远程过程调用（RPCs），并且基本的一致性算法只需要两种类型的 RPCs。请求投票（`RequestVote`） RPCs 由候选人在选举期间发起，然后附加条目（`AppendEntries`）RPCs 由领导人发起，用来复制日志和提供一种心跳机制。为了在服务器之间传输快照增加了第三种 RPC。当服务器没有及时的收到 RPC 的响应时，会进行重试， 并且他们能够并行的发起 RPCs 来获得最佳的性能。

RPC有三种：

1. RequestVote RPC：候选人在选举期间发起
2. AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成
3. InstallSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。

超时设置：

1. BroadcastTime :  领导者的心跳超时时间
2. Election Timeout: 追随者设置的候选超时时间
3. MTBT :指的是单个服务器发生故障的间隔时间的平均数

BroadcastTime << ElectionTimeout << MTBF
 两个原则：

1. BroadcastTime应该比ElectionTimeout小一个数量级，为的是使领导人能够持续发送心跳信息（heartbeat）来阻止追随者们开始选举；
2. ElectionTimeout也要比MTBF小几个数量级，为的是使得系统稳定运行。

一般BroadcastTime大约为0.5毫秒到20毫秒，ElectionTimeout一般在10ms到500ms之间。大多数服务器的MTBF都在几个月甚至更长。



## leader选取问题

**触发条件：**

1. 一般情况下，追随者接到领导者的心跳时，把ElectionTimeout清零，不会触发；
2. 领导者故障，追随者的ElectionTimeout超时发生时，会变成候选者，触发领导人选取；



**候选操作过程：**

> 追随者自增当前任期，转换为Candidate，对自己投票，并发起RequestVote RPC，等待下面三种情形发生；

1. 获得超过半数服务器的投票，赢得选举，成为领导者；
2. 另一台服务器赢得选举，并接收到对应的心跳，成为追随者；
3. 选举超时，没有任何一台服务器赢得选举，自增当前任期，重新发起选举；



- 注意事项：

1. 服务器在一个任期内，最多能给一个候选人投票，采用先到先服务原则；
2. 候选者等待投票时，可能会接收到来自其它声明为领导人的的AppendEntries RPC。如果该领导人的任期（RPC中有）比当前候选人的当前任期要大，则候选人认为该领导人合法，并转换成追随者；如果RPC中的任期小于候选人的当前任期，则候选人拒绝此次RPC，继续保持候选人状态；
3. 候选人既没有赢得选举也没有输掉选举：如果许多追随者在同一时刻都成为了候选人，选票会被分散，可能没有候选人能获得大多数的选票。当这种情形发生时，每一个候选人都会超时，并且通过自增任期号和发起另一轮 RequestVote RPC 来开始新的选举。然而，如果没有其它手段来分配选票的话，这种情形可能会无限的重复下去。所以Raft使用的随机的选举超时时间（150~300ms之间），来避免这种情况发生。

- 问题探讨：为什么这里没有谈收到其他候选者的RequestVote RPC请求？
   可能的解释：

1. 候选者已经给自己投票了，一个候选者在一个任期只会给一个人投票，不会给其他人再投票了；
2. 也有可能算法本身设定候选者就拒绝所有的其他服务器的请求。



## 日志复制

![日志复制问题](https://upload-images.jianshu.io/upload_images/3412164-7bfb13d382599f65.png)

接受命令的过程：

1. 领导者接受客户端请求；
2. 领导者把指令追加到日志；
3. 发送AppendEntries RPC到追随者；
4. 领导者收到大多数追随者的确认后，领导者Commit该日志，把日志在状态机中回放，并返回结果给客户端；



提交过程：

1. 在下一个心跳阶段，领导者再次发送AppendEntries RPC给追随者，日志已经commited；
2. 追随者收到Commited日志后，将日志在状态机中回放。



## 安全性

到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令，例如：一个跟随者可能会进入不可用状态同时领导人已经提交了若干的日志条目，然后这个跟随者可能会被选举为领导人并且覆盖这些日志条目；因此，不同的状态机可能会执行不同的指令序列。

### 1. 领导者追加日志（Append-Only)

领导者永远不会覆盖已经存在的日志条目；
日志永远只有一个流向：从领导者到追随者；

### 2. 选举限制：投票阻止没有全部日志条目的服务器赢得选举

如果投票者的日志比候选人的新，拒绝投票请求；
这意味着要赢得选举，候选者的日志至少和大多数服务器的日志一样新，那么它一定包含全部的已经提交的日志条目。

### 3. 永远不提交任期之前的日志条目（只提交任期内的日志条目）

在Raft算法中，当一个日志被安全的复制到绝大多数的机器上面，即AppendEntries RPC在绝大多数服务器正确返回了，那么这个日志就是被提交了，然后领导者会更新commit index。

![](https://upload-images.jianshu.io/upload_images/3412164-45a235af7798e8f2.png)

如果允许提交任期之前的日志条目，那么在步骤c中，我们就会把之前任期为2的日志提交到其他服务器中去，并造成了大多数机器存在了日志为2的情况。所以造成了d中S5中任期为3的日志条目会覆盖掉已经提交的日志的情况。

Raft 从来不会通过计算复制的数目来提交之前人气的日志条目。只有领导人当前任期的日志条目才能通过计算数目来进行提交。一旦当前任期的日志条目以这种方式被提交，那么由于日志匹配原则（Log Matching Property），之前的日志条目也都会被间接的提交。

论文中的这段话比较难理解，更加直观的说：由于Raft不会提交任期之前的日志条目，那么就不会从b过渡到c的情况，只能从b发生S5down机的情况下直接过渡到e，这样就产生的更新的任期，这样S5就没有机会被选为领导者了。

### 4. 候选者和追随者崩溃

候选者和追随者崩溃的情况处理要简单的多。如果这类角色崩溃了，那么后续发送给他们的 RequestVote和AppendEntries的所有RCP都会失败，Raft算法中处理这类失败就是简单的无限重试的方式。
 　　如果这些服务器重新可用，那么这些RPC就会成功返回。如果一个服务器完成了一个RPC，但是在响应Leader前崩溃了，那么当他再次可用的时候还会收到相同的RPC请求，此时接收服务器负责检查，比如如果收到了已经包含该条日志的RPC请求，可以直接忽略这个请求，确保对系统是无害的。



## 成员变化问题

